{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { useDrawingArea } from '../hooks/useDrawingArea';\nimport { getColorScale, getOrdinalColorScale } from '../internals/colorScale';\nimport { useSeries } from '../hooks/useSeries';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    xExtremumGetters,\n    yExtremumGetters,\n    children\n  } = props;\n  const formattedSeries = useSeries();\n  const drawingArea = useDrawingArea();\n  const xAxis = React.useMemo(() => inXAxis === null || inXAxis === void 0 ? void 0 : inXAxis.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis === null || inYAxis === void 0 ? void 0 : inYAxis.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    var _xAxis$map, _yAxis$map;\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      var _formattedSeries$char, _formattedSeries$char2, _getter;\n      const getter = getters[chartType];\n      const series = (_formattedSeries$char = (_formattedSeries$char2 = formattedSeries[chartType]) === null || _formattedSeries$char2 === void 0 ? void 0 : _formattedSeries$char2.series) !== null && _formattedSeries$char !== void 0 ? _formattedSeries$char : {};\n      const [minChartTypeData, maxChartTypeData] = (_getter = getter === null || getter === void 0 ? void 0 : getter({\n        series,\n        axis,\n        isDefaultAxis\n      })) !== null && _getter !== void 0 ? _getter : [null, null];\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...((_xAxis$map = xAxis === null || xAxis === void 0 ? void 0 : xAxis.map((axis, index) => _extends({\n      id: \"defaultized-x-axis-\".concat(index)\n    }, axis))) !== null && _xAxis$map !== void 0 ? _xAxis$map : []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(_ref => {\n      let {\n        id\n      } = _ref;\n      return id === DEFAULT_X_AXIS_KEY;\n    }) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      var _axis$scaleType, _axis$min, _axis$max, _axis$min2, _axis$max2;\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        var _axis$categoryGapRati, _axis$barGapRatio;\n        const categoryGapRatio = (_axis$categoryGapRati = axis.categoryGapRatio) !== null && _axis$categoryGapRati !== void 0 ? _axis$categoryGapRati : DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = (_axis$barGapRatio = axis.barGapRatio) !== null && _axis$barGapRatio !== void 0 ? _axis$barGapRatio : DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = (_axis$scaleType = axis.scaleType) !== null && _axis$scaleType !== void 0 ? _axis$scaleType : 'linear';\n      const extremums = [(_axis$min = axis.min) !== null && _axis$min !== void 0 ? _axis$min : minData, (_axis$max = axis.max) !== null && _axis$max !== void 0 ? _axis$max : maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [(_axis$min2 = axis.min) !== null && _axis$min2 !== void 0 ? _axis$min2 : niceDomain[0], (_axis$max2 = axis.max) !== null && _axis$max2 !== void 0 ? _axis$max2 : niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    const allYAxis = [...((_yAxis$map = yAxis === null || yAxis === void 0 ? void 0 : yAxis.map((axis, index) => _extends({\n      id: \"defaultized-y-axis-\".concat(index)\n    }, axis))) !== null && _yAxis$map !== void 0 ? _yAxis$map : []), ...(yAxis === undefined || yAxis.findIndex(_ref2 => {\n      let {\n        id\n      } = _ref2;\n      return id === DEFAULT_Y_AXIS_KEY;\n    }) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      var _axis$scaleType2, _axis$min3, _axis$max3, _axis$min4, _axis$max4;\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        var _axis$categoryGapRati2;\n        const categoryGapRatio = (_axis$categoryGapRati2 = axis.categoryGapRatio) !== null && _axis$categoryGapRati2 !== void 0 ? _axis$categoryGapRati2 : DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = (_axis$scaleType2 = axis.scaleType) !== null && _axis$scaleType2 !== void 0 ? _axis$scaleType2 : 'linear';\n      const extremums = [(_axis$min3 = axis.min) !== null && _axis$min3 !== void 0 ? _axis$min3 : minData, (_axis$max3 = axis.max) !== null && _axis$max3 !== void 0 ? _axis$max3 : maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [(_axis$min4 = axis.min) !== null && _axis$min4 !== void 0 ? _axis$min4 : niceDomain[0], (_axis$max4 = axis.max) !== null && _axis$max4 !== void 0 ? _axis$max4 : niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(_ref3 => {\n        let {\n          id\n        } = _ref3;\n        return id;\n      }),\n      yAxisIds: allYAxis.map(_ref4 => {\n        let {\n          id\n        } = _ref4;\n        return id;\n      })\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, xExtremumGetters, yAxis, yExtremumGetters]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };","map":{"version":3,"names":["_extends","React","scaleBand","scalePoint","isBandScaleConfig","isPointScaleConfig","getScale","DEFAULT_X_AXIS_KEY","DEFAULT_Y_AXIS_KEY","getTickNumber","useDrawingArea","getColorScale","getOrdinalColorScale","useSeries","jsx","_jsx","DEFAULT_CATEGORY_GAP_RATIO","DEFAULT_BAR_GAP_RATIO","CartesianContext","createContext","xAxis","yAxis","xAxisIds","yAxisIds","process","env","NODE_ENV","displayName","CartesianContextProvider","props","inXAxis","inYAxis","dataset","xExtremumGetters","yExtremumGetters","children","formattedSeries","drawingArea","useMemo","map","axisConfig","dataKey","undefined","data","Error","d","value","_xAxis$map","_yAxis$map","axisExtremumCallback","acc","chartType","axis","getters","isDefaultAxis","_formattedSeries$char","_formattedSeries$char2","_getter","getter","series","minChartTypeData","maxChartTypeData","minData","maxData","Math","min","max","getAxisExtremum","charTypes","Object","keys","reduce","charType","allXAxis","index","id","concat","findIndex","_ref","scaleType","completedXAxis","forEach","axisIndex","_axis$scaleType","_axis$min","_axis$max","_axis$min2","_axis$max2","range","reverse","left","width","_axis$categoryGapRati","_axis$barGapRatio","categoryGapRatio","barGapRatio","scale","paddingInner","paddingOuter","tickNumber","length","colorScale","colorMap","type","values","extremums","domain","niceScale","nice","niceDomain","allYAxis","_ref2","completedYAxis","_axis$scaleType2","_axis$min3","_axis$max3","_axis$min4","_axis$max4","top","height","_axis$categoryGapRati2","_ref3","_ref4","Provider"],"sources":["C:/Users/lyont/GithubProfile/backendstesting/LET-FrontEnd/node_modules/@mui/x-charts/esm/context/CartesianContextProvider.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { useDrawingArea } from '../hooks/useDrawingArea';\nimport { getColorScale, getOrdinalColorScale } from '../internals/colorScale';\nimport { useSeries } from '../hooks/useSeries';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    xExtremumGetters,\n    yExtremumGetters,\n    children\n  } = props;\n  const formattedSeries = useSeries();\n  const drawingArea = useDrawingArea();\n  const xAxis = React.useMemo(() => inXAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      const getter = getters[chartType];\n      const series = formattedSeries[chartType]?.series ?? {};\n      const [minChartTypeData, maxChartTypeData] = getter?.({\n        series,\n        axis,\n        isDefaultAxis\n      }) ?? [null, null];\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...(xAxis?.map((axis, index) => _extends({\n      id: `defaultized-x-axis-${index}`\n    }, axis)) ?? []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(({\n      id\n    }) => id === DEFAULT_X_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    const allYAxis = [...(yAxis?.map((axis, index) => _extends({\n      id: `defaultized-y-axis-${index}`\n    }, axis)) ?? []), ...(yAxis === undefined || yAxis.findIndex(({\n      id\n    }) => id === DEFAULT_Y_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(({\n        id\n      }) => id),\n      yAxisIds: allYAxis.map(({\n        id\n      }) => id)\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, xExtremumGetters, yAxis, yExtremumGetters]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}