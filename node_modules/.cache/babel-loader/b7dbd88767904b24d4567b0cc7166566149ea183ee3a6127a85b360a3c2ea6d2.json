{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { useDrawingArea } from '../hooks/useDrawingArea';\nimport { getColorScale, getOrdinalColorScale } from '../internals/colorScale';\nimport { useSeries } from '../hooks/useSeries';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    xExtremumGetters,\n    yExtremumGetters,\n    children\n  } = props;\n  const formattedSeries = useSeries();\n  const drawingArea = useDrawingArea();\n  const xAxis = React.useMemo(() => inXAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      const getter = getters[chartType];\n      const series = formattedSeries[chartType]?.series ?? {};\n      const [minChartTypeData, maxChartTypeData] = getter?.({\n        series,\n        axis,\n        isDefaultAxis\n      }) ?? [null, null];\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...(xAxis?.map((axis, index) => _extends({\n      id: `defaultized-x-axis-${index}`\n    }, axis)) ?? []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(({\n      id\n    }) => id === DEFAULT_X_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    const allYAxis = [...(yAxis?.map((axis, index) => _extends({\n      id: `defaultized-y-axis-${index}`\n    }, axis)) ?? []), ...(yAxis === undefined || yAxis.findIndex(({\n      id\n    }) => id === DEFAULT_Y_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(({\n        id\n      }) => id),\n      yAxisIds: allYAxis.map(({\n        id\n      }) => id)\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, xExtremumGetters, yAxis, yExtremumGetters]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };","map":{"version":3,"names":["_extends","React","scaleBand","scalePoint","isBandScaleConfig","isPointScaleConfig","getScale","DEFAULT_X_AXIS_KEY","DEFAULT_Y_AXIS_KEY","getTickNumber","useDrawingArea","getColorScale","getOrdinalColorScale","useSeries","jsx","_jsx","DEFAULT_CATEGORY_GAP_RATIO","DEFAULT_BAR_GAP_RATIO","CartesianContext","createContext","xAxis","yAxis","xAxisIds","yAxisIds","process","env","NODE_ENV","displayName","CartesianContextProvider","props","inXAxis","inYAxis","dataset","xExtremumGetters","yExtremumGetters","children","formattedSeries","drawingArea","useMemo","map","axisConfig","dataKey","undefined","data","Error","d","value","axisExtremumCallback","acc","chartType","axis","getters","isDefaultAxis","getter","series","minChartTypeData","maxChartTypeData","minData","maxData","Math","min","max","getAxisExtremum","charTypes","Object","keys","reduce","charType","allXAxis","index","id","findIndex","scaleType","completedXAxis","forEach","axisIndex","range","reverse","left","width","categoryGapRatio","barGapRatio","scale","paddingInner","paddingOuter","tickNumber","length","colorScale","colorMap","type","values","extremums","domain","niceScale","nice","niceDomain","allYAxis","completedYAxis","top","height","Provider"],"sources":["C:/Users/lyont/GithubProfile/backendstesting/LET-FrontEnd/node_modules/@mui/x-charts/esm/context/CartesianContextProvider.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { useDrawingArea } from '../hooks/useDrawingArea';\nimport { getColorScale, getOrdinalColorScale } from '../internals/colorScale';\nimport { useSeries } from '../hooks/useSeries';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    xExtremumGetters,\n    yExtremumGetters,\n    children\n  } = props;\n  const formattedSeries = useSeries();\n  const drawingArea = useDrawingArea();\n  const xAxis = React.useMemo(() => inXAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      const getter = getters[chartType];\n      const series = formattedSeries[chartType]?.series ?? {};\n      const [minChartTypeData, maxChartTypeData] = getter?.({\n        series,\n        axis,\n        isDefaultAxis\n      }) ?? [null, null];\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...(xAxis?.map((axis, index) => _extends({\n      id: `defaultized-x-axis-${index}`\n    }, axis)) ?? []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(({\n      id\n    }) => id === DEFAULT_X_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    const allYAxis = [...(yAxis?.map((axis, index) => _extends({\n      id: `defaultized-y-axis-${index}`\n    }, axis)) ?? []), ...(yAxis === undefined || yAxis.findIndex(({\n      id\n    }) => id === DEFAULT_Y_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(({\n        id\n      }) => id),\n      yAxisIds: allYAxis.map(({\n        id\n      }) => id)\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, xExtremumGetters, yAxis, yExtremumGetters]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}